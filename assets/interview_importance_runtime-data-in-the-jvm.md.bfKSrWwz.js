import{_ as e,B as i,o as n,c as l,j as a,a as r,G as s,a8 as p}from"./chunks/framework.D0fTRY1a.js";const V=JSON.parse('{"title":"JVM规范中的运行时数据区","description":"","frontmatter":{"title":"JVM规范中的运行时数据区","order":20,"pageview":false,"date":"2024-07-09T15:57:24.000Z","comment":false,"breadcrumb":false},"headers":[],"relativePath":"interview/importance/runtime-data-in-the-jvm.md","filePath":"interview/importance/runtime-data-in-the-jvm.md","lastUpdated":null}'),c={name:"interview/importance/runtime-data-in-the-jvm.md"};function g(d,t,m,h,J,u){const o=i("ArticleMetadata");return n(),l("div",null,[t[0]||(t[0]=a("h1",{id:"jvm规范中的运行时数据区",tabindex:"-1"},[r("JVM规范中的运行时数据区 "),a("a",{class:"header-anchor",href:"#jvm规范中的运行时数据区","aria-label":'Permalink to "JVM规范中的运行时数据区"'},"​")],-1)),s(o),t[1]||(t[1]=p('<h2 id="jvm规范数据区" tabindex="-1">JVM规范数据区 <a class="header-anchor" href="#jvm规范数据区" aria-label="Permalink to &quot;JVM规范数据区&quot;">​</a></h2><ol><li><strong>The pc Register（程序计数器）：</strong> 是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址；</li><li><strong>Java Virtual Machine Stacks（Java虚拟机栈）：</strong> Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li><strong>Heap（堆）：</strong> 是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。</li><li><strong>Method Area（方法区）：</strong> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li><strong>Run-Time Constant Pool（运行时常量池）：</strong> 是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。</li><li><strong>Native Method Stacks（本地方法栈）：</strong> 在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。</li></ol><p><strong>总结：</strong> 这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。</p><p>下图为JVM结构规范图，该图属于JVM规范，不是具体的实现。JVM规范最开始是由研究Java的大佬们定制的，但是后面JVM规范的实现可能有很多公司，比如我们最熟悉的Oracle等等，这点一定要区分开。</p><p><strong>JVM规范的实现：HotSpot（Oracle JDK/Open JDK内部使用的JVM就是HotSpot）</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202404100923253.png" alt="img" loading="lazy"></p><h2 id="jdk6的hotspot" tabindex="-1">JDK6的HotSpot <a class="header-anchor" href="#jdk6的hotspot" aria-label="Permalink to &quot;JDK6的HotSpot&quot;">​</a></h2><p>JDK6的HotSpot大致分为以下几个数据区。</p><ul><li><strong>年轻代：</strong> 刚new出来的对象放在这里。</li><li><strong>老年代：</strong> 经过垃圾回收之后仍然存活的对象。</li><li><strong>符号引用：</strong> 类全名，字段全名，方法全名等。</li><li>这个时期的永久代和堆是相邻的，使用连续的物理内存，但是内存空间是隔离的。</li><li>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202404100923144.png" alt="img" loading="lazy"></p><h2 id="jdk7的hotspot" tabindex="-1">JDK7的HotSpot <a class="header-anchor" href="#jdk7的hotspot" aria-label="Permalink to &quot;JDK7的HotSpot&quot;">​</a></h2><p>以下是JDK7的HotSpot，这是一个过渡的版本，该版本相对于JDK6来说，变化如下：</p><ol><li>类的静态变量转移到堆中了。（<strong>这就是各个版本实现的不同，在JVM规范以及JDK6来说，类的静态变量是在方法区中，而在JDK7中，类的静态变量在堆内存中。）</strong></li><li>字符串常量池转移到堆中了。</li><li>运行时常量池中的符号引用转移到本地内存了。</li></ol><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202404100923284.png" alt="img" loading="lazy"></p><h2 id="jdk8的hotspot" tabindex="-1">JDK8的HotSpot <a class="header-anchor" href="#jdk8的hotspot" aria-label="Permalink to &quot;JDK8的HotSpot&quot;">​</a></h2><p>以下是JDK8及更高版本的HotSpot，相对于JDK7来说发生了如下变化：</p><ol><li>彻底删除永久代**（为了避免OOM错误的发生，方法区更名为元空间）**。</li><li><strong>将方法区的实现转移到本地内存。</strong></li><li>将符号引用重新放回运行时常量池。</li></ol><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202404100923202.png" alt="img" loading="lazy"></p>',18))])}const _=e(c,[["render",g]]);export{V as __pageData,_ as default};
