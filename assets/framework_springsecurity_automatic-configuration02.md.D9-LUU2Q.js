import{_ as t,B as n,o as i,c as r,j as o,a as s,G as l,a8 as c}from"./chunks/framework.D0fTRY1a.js";const B=JSON.parse('{"title":"SpringSecurity6 | 自动配置(下)","description":"","frontmatter":{},"headers":[],"relativePath":"framework/springsecurity/automatic-configuration02.md","filePath":"framework/springsecurity/automatic-configuration02.md","lastUpdated":null}'),p={name:"framework/springsecurity/automatic-configuration02.md"};function d(g,e,u,h,m,y){const a=n("ArticleMetadata");return i(),r("div",null,[e[0]||(e[0]=o("h1",{id:"springsecurity6-自动配置-下",tabindex:"-1"},[s("SpringSecurity6 | 自动配置(下) "),o("a",{class:"header-anchor",href:"#springsecurity6-自动配置-下","aria-label":'Permalink to "SpringSecurity6 | 自动配置(下)"'},"​")],-1)),l(a),e[1]||(e[1]=c('<p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311162329387.png" alt="image-20231030235443828" loading="lazy"></p><h2 id="_1-前言" tabindex="-1">1.前言 <a class="header-anchor" href="#_1-前言" aria-label="Permalink to &quot;1.前言&quot;">​</a></h2><p>大家好，我是Leo哥🫣🫣🫣，上一节我们揭开了为什么引入依赖之后就会进行登录鉴权这一神秘面纱，了解复习了关于SpringBoot的自动配置以及如何一步一步的通过自动配置让我们请求加上认证权限。本次我们接着讨论关于自动配置相关问题。好了，话不多说让我们开始吧😎😎😎。</p><h2 id="_2-问题引出" tabindex="-1">2.问题引出 <a class="header-anchor" href="#_2-问题引出" aria-label="Permalink to &quot;2.问题引出&quot;">​</a></h2><p>既然我们知道了有关SpringBoot自动装配的一些基本流程。具体的方法调用路径或者叫配置路径是这样的：首先是三个核心的注解：</p><blockquote><p>@SpringBootApplication-&gt; @EnableAutoConfiguration&gt;@Import(AutoConfigurationImportSelector)</p></blockquote><p>然后通过@Import注解去加载他的所有配置文件到SpringBoot中。这样加载到SpringSecurity的核心文件。最终调用到上边的方法，导致所有的方法都得进行登录认证。</p><p>那么这些个注解尤其是**@Import**是如何生效的呢，具体是怎么生效的呢，在什么时候被加载呢，其实上一篇文章我们已经有了一些简单的了解，这节课我们随着Leo哥的视角通过源码方式来深入学习一下。</p><h2 id="_3-再看自动装配" tabindex="-1">3.再看自动装配 <a class="header-anchor" href="#_3-再看自动装配" aria-label="Permalink to &quot;3.再看自动装配&quot;">​</a></h2><h3 id="_3-1-run方法到注解解读器" tabindex="-1">3.1 run方法到注解解读器 <a class="header-anchor" href="#_3-1-run方法到注解解读器" aria-label="Permalink to &quot;3.1 run方法到注解解读器&quot;">​</a></h3><p>我们找到我们项目的启动类。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311172321510.png" alt="image-20231117232122451" loading="lazy"></p><p>然后通过Ctrl + 鼠标左键，点进去run方法。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311172324287.png" alt="image-20231117232424261" loading="lazy"></p><p>我们查看这个里面的构造方法：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181237365.png" alt="image-20231118123722315" loading="lazy"></p><p>然后我们找到run()方法</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181243052.png" alt="image-20231118124312944" loading="lazy"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181240025.png" alt="image-20231118124041959" loading="lazy"></p><p>可以看到这个prepareContext这个方法。它接受6个参数，分别是<code>bootstrapContext</code>，<code>context</code>，<code>environment</code>，<code>listeners</code>，<code>applicationArguments</code>和printedBanner，并对这些参数进行处理以准备上下文。</p><p>然后我们通过Ctrl + 鼠标左键，点到prepareContext这个里面去查看。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181242143.png" alt="image-20231118124238053" loading="lazy"></p><p>那么他在这里做了什么准备工作呢，我们来简单分析一下：</p><p>它的功能是在Spring应用启动过程中准备并设置应用上下文（ApplicationContext）</p><ol><li><strong>设置环境并处理应用上下文</strong>: <ul><li><code>context.setEnvironment(environment)</code>: 将配置环境设置到应用上下文中。</li><li><code>postProcessApplicationContext(context)</code>: 对应用上下文进行后处理，可能涉及一些自定义配置或修改。</li><li><code>addAotGeneratedInitializerIfNecessary(this.initializers)</code>: 如果需要，添加Ahead-of-Time (AOT) 生成的初始化器到应用的初始化器列表中。</li><li><code>applyInitializers(context)</code>: 应用之前添加的所有初始化器到应用上下文。</li></ul></li><li><strong>通知监听器上下文已准备好</strong>: <ul><li><code>listeners.contextPrepared(context)</code>: 通知Spring应用运行监听器，上下文已准备完成。</li><li><code>bootstrapContext.close(context)</code>: 关闭引导上下文。</li></ul></li><li><strong>启动信息日志</strong>: <ul><li>如果启用了启动日志（<code>this.logStartupInfo</code>），则记录启动信息和配置文件信息。</li></ul></li><li><strong>注册Spring Boot特定的单例Bean</strong>: <ul><li>向Bean工厂注册<code>springApplicationArguments</code>和<code>springBootBanner</code>（如果存在的话）。</li></ul></li><li><strong>处理Bean工厂配置</strong>: <ul><li>设置允许循环引用（<code>setAllowCircularReferences</code>）和允许Bean定义覆盖（<code>setAllowBeanDefinitionOverriding</code>），根据配置决定。</li></ul></li><li><strong>懒加载和属性源排序处理</strong>: <ul><li>如果启用了懒加载（<code>this.lazyInitialization</code>），则添加相关的BeanFactoryPostProcessor。</li><li>添加一个用于属性源排序的BeanFactoryPostProcessor。</li></ul></li><li><strong>加载应用的源</strong>: <ul><li>如果没有使用AOT生成的工件，那么将从<code>getAllSources()</code>获取所有源，并使用<code>load(context, sources.toArray(new Object[0]))</code>加载它们。</li></ul></li><li><strong>通知监听器上下文已加载</strong>: <ul><li><code>listeners.contextLoaded(context)</code>: 通知监听器上下文加载完成。</li></ul></li></ol><p><strong>主要作用：</strong> 识别入口类，读取入口类的所有内容包括注解在内。并注册到注解解读器announationreader中，方便后续注解进行解析。</p><p>通过<code>getAllSources()</code>获取所有源信息，也就是我们当前的入口类信息，然后把这些source放到一个set集合中，最后去加载load，接下来我们点开load方法继续查看。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181250331.png" alt="image-20231118125037298" loading="lazy"></p><ol><li>首先，它检查logger是否处于调试模式（debugEnabled）。如果处于调试模式，它会记录一条调试日志，显示正在加载的源（sources）。</li><li>然后，它创建一个BeanDefinitionLoader实例。这个实例是用于加载Bean定义的。它使用getBeanDefinitionRegistry(context)方法获取BeanDefinitionRegistry，然后使用createBeanDefinitionLoader()方法创建一个BeanDefinitionLoader实例。</li><li>如果beanNameGenerator属性不为null，它将beanNameGenerator设置为loader的属性。</li><li>如果resourceLoader属性不为null，它将resourceLoader设置为loader的属性。</li><li>如果environment属性不为null，它将environment设置为loader的属性。</li><li>最后，调用loader的load()方法来加载Bean定义。</li></ol><p>到这里，前面的工作已经基本完成了：读取入口类中重要的信息，包括注解包括入口类本身。将入口类中的注解注册到注解解读器<code>annotationreader</code>当中。</p><h3 id="_3-2-加载bean" tabindex="-1">3.2 加载Bean <a class="header-anchor" href="#_3-2-加载bean" aria-label="Permalink to &quot;3.2 加载Bean&quot;">​</a></h3><p>真正解析Bean的工作是从<code>refreshContext</code>当中进行的。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181253938.png" alt="image-20231118125314882" loading="lazy"></p><p>首先通通过prepareContext方法进行准备，然后通过refreshContext进行装载工作，那么他具体是怎么进行转载的呢，下面我们点进去这个方法继续查看。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181254264.png" alt="image-20231118125430218" loading="lazy"></p><p>这部分代码涉及应用上下文的刷新动作。这里我逐行解释一下：</p><p><strong>注册关闭钩子（shutdown hook）</strong>:</p><ul><li><code>if (this.registerShutdownHook)</code>: 首先检查一个布尔标志<code>this.registerShutdownHook</code>，判断是否需要注册一个shutdown hook。这个标志通常是在Spring Boot的配置中设置的，用以确定我们是否希望在JVM关闭时能够自动清理和关闭Spring上下文。</li><li><code>shutdownHook.registerApplicationContext(context)</code>: 如果需要注册shutdown hook，这行代码执行注册操作。具体来说，<code>shutdownHook</code>是一个管理器（可能是Spring Boot中的一个组件），负责注册和执行关闭Spring应用上下文的逻辑。当JVM进程结束时，这个shutdown hook将得到执行。</li></ul><p>最后跑到了一个applicationContext的refresh方法当中。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181257877.png" alt="image-20231118125721796" loading="lazy"></p><p><strong>刷新应用上下文</strong>:</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refresh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这是调用ApplicationContext的</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">refresh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>方法，该方法是启动和重新启动Spring上下文的核心方法。它会执行以下关键步骤：</p><ul><li>准备上下文环境（比如设置必要的属性源、验证必要的环境变量等）。</li><li>实例化和初始化所有的Bean，包括Spring配置中声明的Bean以及注解声明的Bean。</li><li>如果有的话，运行BeanFactory后处理器。</li><li>触发任何实现ApplicationContextAware接口的Bean，让它们能够感知到自己所处的ApplicationContext。</li><li>最后，发送上下文刷新事件，这将通知所有监听器上下文已经完全初始化和可用。</li></ul><p>这个<code>refreshContext</code>方法的目的是确保SpringBoot应用中的ApplicationContext处于最新状态，具备服务请求的能力。这通常发生在应用启动时，或者需要重新加载上下文配置的任何时候。</p><p>接下来会进行Bean处理的13方法，<strong>其中一个比较关键的方法：</strong> <code>invokeBeanFactoryPostProcessors</code></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181259020.png" alt="image-20231118125934988" loading="lazy"></p><p>我们点过去这个方法</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311181300826.png" alt="image-20231118130018787" loading="lazy"></p><ol><li><p><code>invokeBeanFactoryPostProcessors</code> 方法接收一个 <code>ConfigurableListableBeanFactory</code> 类型的参数 <code>beanFactory</code>。</p></li><li><p><code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())</code> 这一行调用了 <code>PostProcessorRegistrationDelegate</code> 类的 <code>invokeBeanFactoryPostProcessors</code> 方法，传入了两个参数，即当前的 <code>beanFactory</code> 和获取的一些BeanFactory后处理器列表（通过 <code>getBeanFactoryPostProcessors()</code> 获取）。</p></li><li><p>接下来的注释提到了检测 <code>LoadTimeWeaver</code> 并准备进行织入（weaving）。具体地说，它通过以下条件进行检查：</p><ul><li><code>NativeDetector.inNativeImage()</code> 确保不在本机镜像环境下。</li><li><code>beanFactory.getTempClassLoader() == null</code> 确保临时类加载器为空。</li><li><code>beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)</code> 确保BeanFactory中包含名为 <code>LOAD_TIME_WEAVER_BEAN_NAME</code> 的bean。</li></ul></li><li><p>如果以上条件都满足，那么会执行以下两个操作：</p><ul><li><code>beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory))</code> 添加一个 <code>LoadTimeWeaverAwareProcessor</code> 的Bean后处理器。</li><li><code>beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()))</code> 设置临时类加载器为 <code>ContextTypeMatchClassLoader</code> 类的实例，该实例使用当前的 <code>beanFactory</code> 的类加载器。</li></ul><p><strong>总结：</strong></p><p>经常<code>refresh()</code>的层层调用2进到AbstractApplicationContext类中refresh0方法，该方法主要有13 个步骤用于对bean对象进行解析加载，其中第5步<code>invokeBeanFactoryPostProcessors()</code>进行核心加 载类上的**@Configurer**、<strong>@Bean</strong>、<strong>@Import</strong>等注解。</p></li></ol><h2 id="_6-参考文献" tabindex="-1">6.参考文献 <a class="header-anchor" href="#_6-参考文献" aria-label="Permalink to &quot;6.参考文献&quot;">​</a></h2><ul><li><a href="https://springdoc.cn/spring-security/servlet/architecture.html" target="_blank" rel="noreferrer">https://springdoc.cn/spring-security/servlet/architecture.html</a></li><li><a href="http://springboot.fun/" target="_blank" rel="noreferrer">http://springboot.fun/</a></li></ul><h2 id="_7-总结" tabindex="-1">7.总结 <a class="header-anchor" href="#_7-总结" aria-label="Permalink to &quot;7.总结&quot;">​</a></h2><p>以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是<strong>Leo</strong>，一个在互联网行业的小白，立志成为更好的自己。</p><p>如果你想了解更多关于<strong>Leo</strong>，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。</p>',57))])}const P=t(p,[["render",d]]);export{B as __pageData,P as default};
