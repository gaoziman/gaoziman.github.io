import{_ as n,B as t,o as e,c as r,j as a,a as l,G as p,a8 as h}from"./chunks/framework.D0fTRY1a.js";const m=JSON.parse('{"title":"服务端渲染与客户端渲染","description":"","frontmatter":{},"headers":[],"relativePath":"fragment/server-rendering-and-client-rendering.md","filePath":"fragment/server-rendering-and-client-rendering.md","lastUpdated":null}'),d={name:"fragment/server-rendering-and-client-rendering.md"};function o(k,s,g,c,u,b){const i=t("ArticleMetadata");return e(),r("div",null,[s[0]||(s[0]=a("h1",{id:"服务端渲染与客户端渲染",tabindex:"-1"},[l("服务端渲染与客户端渲染 "),a("a",{class:"header-anchor",href:"#服务端渲染与客户端渲染","aria-label":'Permalink to "服务端渲染与客户端渲染"'},"​")],-1)),p(i),s[1]||(s[1]=h(`<h2 id="什么是客户端渲染-什么是服务端渲染" tabindex="-1">什么是客户端渲染，什么是服务端渲染？ <a class="header-anchor" href="#什么是客户端渲染-什么是服务端渲染" aria-label="Permalink to &quot;什么是客户端渲染，什么是服务端渲染？&quot;">​</a></h2><p>服务端渲染（Server-Side Rendering, SSR）和客户端渲染（Client-Side Rendering, CSR）是两种常见的网页内容渲染方式，决定了应用中的网页如何从数据转化为可以在浏览器中显示的HTML。</p><h3 id="_1-服务端渲染-ssr" tabindex="-1">1. <strong>服务端渲染（SSR）</strong> <a class="header-anchor" href="#_1-服务端渲染-ssr" aria-label="Permalink to &quot;1. **服务端渲染（SSR）**&quot;">​</a></h3><p><strong>定义</strong>：服务端渲染是指在服务器上生成完整的HTML页面，然后将这个HTML页面发送给客户端浏览器。浏览器只需要接收并直接显示这些HTML内容。</p><h4 id="工作流程" tabindex="-1">工作流程： <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程：&quot;">​</a></h4><ol><li><p><strong>用户请求</strong>：用户在浏览器中发起对一个页面的请求。</p></li><li><p><strong>服务器处理</strong>：服务器接收到请求后，运行服务器端代码（例如PHP、Node.js等），生成HTML页面。</p></li><li><p><strong>返回HTML</strong>：服务器将完整的HTML页面发送回浏览器。</p></li><li><p><strong>浏览器显示</strong>：浏览器接收到完整的HTML，直接渲染并显示给用户。</p></li></ol><h4 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h4><ul><li><p><strong>更快的首次渲染</strong>：用户在第一次访问时，页面会更快显示，因为HTML是服务器生成的，浏览器只需直接渲染。</p></li><li><p><strong>SEO友好</strong>：因为完整的HTML页面在服务器上生成，搜索引擎爬虫能够轻松地索引和抓取页面内容。</p></li><li><p><strong>适合内容较多的页面</strong>：对于数据量大、内容较多的网站（如博客、新闻网站等），服务端渲染可以减少首次加载的时间。</p></li></ul><h4 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h4><ul><li><p><strong>每次请求都需要服务器生成页面</strong>：每个页面刷新都会导致服务器生成新的HTML，可能会增加服务器负载，尤其是高流量网站。</p></li><li><p><strong>交互性差</strong>：页面的交互通常需要在用户每次请求页面时重新加载整个页面。</p></li></ul><h4 id="示例" tabindex="-1">示例： <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例：&quot;">​</a></h4><p>传统的Web应用（如PHP网站、Ruby on Rails应用等）通常采用服务端渲染。例如：</p><div class="language-PHP vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">PHP</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">html</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">php</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;h1&gt;Hello, &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> .</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;!&lt;/h1&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ?&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">html</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>用户请求时，服务器会运行PHP代码，生成HTML并发送给浏览器。</p><hr><h3 id="_2-客户端渲染-csr" tabindex="-1">2. <strong>客户端渲染（CSR）</strong> <a class="header-anchor" href="#_2-客户端渲染-csr" aria-label="Permalink to &quot;2. **客户端渲染（CSR）**&quot;">​</a></h3><p><strong>定义</strong>：客户端渲染是指将应用的HTML、CSS、JavaScript代码传输到浏览器，由浏览器在客户端执行JavaScript代码生成HTML，最后渲染页面。</p><h4 id="工作流程-1" tabindex="-1">工作流程： <a class="header-anchor" href="#工作流程-1" aria-label="Permalink to &quot;工作流程：&quot;">​</a></h4><ol><li><p><strong>用户请求</strong>：用户请求一个页面。</p></li><li><p><strong>服务器返回静态文件</strong>：服务器返回一个包含HTML结构（通常很简单）和JavaScript代码的文件。</p></li><li><p><strong>客户端执行</strong>：浏览器加载JavaScript代码，并通过AJAX请求或其他方式从服务器获取数据，生成完整的HTML结构。</p></li><li><p><strong>渲染页面</strong>：浏览器在客户端生成并渲染HTML内容。</p></li></ol><h4 id="优点-1" tabindex="-1">优点： <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点：&quot;">​</a></h4><ul><li><p><strong>更好的用户体验</strong>：页面交互可以在不重新加载整个页面的情况下进行，增强了应用的响应性和流畅度。</p></li><li><p><strong>减少服务器负担</strong>：因为大部分渲染是在客户端进行的，服务器压力较小。</p></li><li><p><strong>单页应用（SPA）支持</strong>：CSR通常用于单页应用（Single Page Applications），例如通过Vue.js、React、Angular等框架构建的应用。用户不需要每次操作都请求新页面，只需请求和更新所需的数据。</p></li></ul><h4 id="缺点-1" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点：&quot;">​</a></h4><ul><li><p><strong>首次加载时间较慢</strong>：浏览器在加载页面时需要下载所有的JavaScript文件，并等待JavaScript代码执行，页面内容才会显示出来。</p></li><li><p><strong>SEO问题</strong>：由于搜索引擎爬虫可能无法执行JavaScript，因此动态生成的内容不容易被抓取。不过，现代前端框架已经逐渐提供解决方案，例如静态站点生成（SSG）和预渲染。</p></li></ul><h4 id="示例-1" tabindex="-1">示例： <a class="header-anchor" href="#示例-1" aria-label="Permalink to &quot;示例：&quot;">​</a></h4><p>使用React进行客户端渲染：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, World!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;, document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在CSR中，<code>index.html</code>只包含一个简单的容器（如<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>），页面内容是通过JavaScript代码动态生成的。</p><hr><h3 id="_3-ssr与csr的对比" tabindex="-1">3. <strong>SSR与CSR的对比</strong> <a class="header-anchor" href="#_3-ssr与csr的对比" aria-label="Permalink to &quot;3. **SSR与CSR的对比**&quot;">​</a></h3><table tabindex="0"><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>服务端渲染（SSR）</td><td>客户端渲染（CSR）</td></tr><tr><td><strong>首次加载速度</strong></td><td>较快，服务器生成完整页面</td><td>较慢，需下载并执行JavaScript</td></tr><tr><td><strong>交互体验</strong></td><td>页面交互需要重新加载页面</td><td>更好的交互体验，页面部分更新无需重新加载</td></tr><tr><td><strong>SEO</strong></td><td>非常友好，页面内容可以轻松被搜索引擎抓取</td><td>需要额外处理（如使用预渲染或静态站点生成）</td></tr><tr><td><strong>服务器压力</strong></td><td>服务器负担较大，每次请求都需生成HTML</td><td>服务器压力较小，渲染工作在客户端进行</td></tr><tr><td><strong>复杂性</strong></td><td>简单，传统Web应用常用</td><td>较复杂，前端代码需要处理渲染和逻辑</td></tr></tbody></table><hr><h3 id="_4-混合模式-同构渲染-isomorphic-universal-rendering" tabindex="-1">4. <strong>混合模式：同构渲染（Isomorphic/Universal Rendering）</strong> <a class="header-anchor" href="#_4-混合模式-同构渲染-isomorphic-universal-rendering" aria-label="Permalink to &quot;4. **混合模式：同构渲染（Isomorphic/Universal Rendering）**&quot;">​</a></h3><p>为了弥补SSR和CSR的缺点，现代Web应用中常用同构渲染（也叫Universal渲染），它结合了SSR和CSR的优点：</p><ul><li><p><strong>首次渲染在服务器上完成</strong>，以便快速加载并改善SEO。</p></li><li><p>然后<strong>后续交互在客户端进行</strong>，通过前端框架动态更新页面，增强用户体验。</p></li></ul><p>例如，Next.js（基于React）提供了这种同构渲染的能力。</p><hr><p>总结来说，<strong>服务端渲染</strong>适合内容相对固定、需要较快首屏加载的网站，而<strong>客户端渲染</strong>适合需要大量交互的单页应用。实际项目中，很多网站会使用两者的结合，或者借助同构渲染提升性能与用户体验。</p>`,37))])}const y=n(d,[["render",o]]);export{m as __pageData,y as default};
