import{_ as e,B as k,o as r,c as E,j as i,a,G as n,w as p,a8 as t}from"./chunks/framework.D0fTRY1a.js";const m=JSON.parse('{"title":"Static关键字作用及用法","description":"","frontmatter":{},"headers":[],"relativePath":"interview/importance/static-keyword-function-and-usage.md","filePath":"interview/importance/static-keyword-function-and-usage.md","lastUpdated":null}'),d={name:"interview/importance/static-keyword-function-and-usage.md"};function g(y,s,c,b,o,u){const h=k("ArticleMetadata"),l=k("font");return r(),E("div",null,[s[22]||(s[22]=i("h1",{id:"static关键字作用及用法",tabindex:"-1"},[a("Static关键字作用及用法 "),i("a",{class:"header-anchor",href:"#static关键字作用及用法","aria-label":'Permalink to "Static关键字作用及用法"'},"​")],-1)),n(h),s[23]||(s[23]=i("h2",{id:"_1-概述",tabindex:"-1"},[a("1. 概述 "),i("a",{class:"header-anchor",href:"#_1-概述","aria-label":'Permalink to "1. 概述"'},"​")],-1)),s[24]||(s[24]=i("blockquote",null,[i("p",null,"Static是静态修饰符，什么叫静态修饰符呢？大家都知道，在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的，而所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。这样做有什么意义呢？在Java程序里面，所有的东西都是对象，而对象的抽象就是类，对于一个类而言，如果要使用他的成员，那么普通情况下必须先实例化对象后，通过对象的引用才能够访问这些成员，但是用static修饰的成员可以通过类名加“.”进行直接访问。")],-1)),n(l,{color:"blue"},{default:p(()=>s[0]||(s[0]=[a("官方解释")])),_:1}),s[25]||(s[25]=t("",23)),n(l,{size:"4"},{default:p(()=>s[1]||(s[1]=[a("什么是句柄")])),_:1}),s[26]||(s[26]=t("",7)),n(l,{size:"5"},{default:p(()=>[n(l,{color:"blue"},{default:p(()=>s[2]||(s[2]=[a("控制台输出")])),_:1})]),_:1}),s[27]||(s[27]=i("p",null,[i("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308181113774.png",alt:"image-20230818111309548",loading:"lazy"})],-1)),s[28]||(s[28]=i("p",null,"从控制台输出的结果，可以看到：",-1)),i("ul",null,[s[6]||(s[6]=i("li",null,"如果给 属性 赋默认值，在上面的例子中是(description 和 pub)，输出的结果为都是默认的。",-1)),i("li",null,[s[4]||(s[4]=a("当我们修改了类中 ")),n(l,{color:"DarkOrange"},{default:p(()=>s[3]||(s[3]=[a("static")])),_:1}),s[5]||(s[5]=a(" 关键字声明的属性，那么只要修改了一次，那么其他所有的对象的这个属性都给修改了。"))])]),s[29]||(s[29]=t("",5)),n(l,{size:"5"},{default:p(()=>[n(l,{color:"blue"},{default:p(()=>s[7]||(s[7]=[a("控制台输出")])),_:1})]),_:1}),s[30]||(s[30]=i("p",null,[i("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308181120814.png",alt:"image-20230818112054747",loading:"lazy"})],-1)),n(l,{size:"4"},{default:p(()=>s[8]||(s[8]=[i("span",{style:{color:"red"}},"**由此，我们看出，在没有实例化对象的时候，就可以直接通过类去掉用 static属性，并且还可以修改 static 的属性。static 属性声明虽然是在类的结构中，但是并不受到对象的控制，是独立存在的。**",-1)])),_:1}),s[31]||(s[31]=i("h3",{id:"static-属性与非-static-属性的区别",tabindex:"-1"},[a("static 属性与非 static 属性的区别 "),i("a",{class:"header-anchor",href:"#static-属性与非-static-属性的区别","aria-label":'Permalink to "static 属性与非 static 属性的区别"'},"​")],-1)),s[32]||(s[32]=i("ul",null,[i("li",null,[i("p",null,"static 声明的属性和普通属性（非 static 属性）最大的区别在于保存的内存区域不同。static 所修饰的在静态数据区。而不是在堆和栈。")]),i("li",null,[i("p",null,"static 属性与非 static 属性还有一个最大的区别，就是在于所有非 static 属性必须产生实例化之后才可以访问，但是static 属性不受实例化对象的控制。也就是说，在没有产生实例化对象的情况下，依然可以使用 static 对象。")])],-1)),s[33]||(s[33]=i("h2",{id:"_3-修饰成员方法",tabindex:"-1"},[a("3. 修饰成员方法 "),i("a",{class:"header-anchor",href:"#_3-修饰成员方法","aria-label":'Permalink to "3. 修饰成员方法"'},"​")],-1)),n(l,{color:"blue"},{default:p(()=>s[9]||(s[9]=[a("**说明**")])),_:1}),s[34]||(s[34]=t("",2)),n(l,{size:"5"},{default:p(()=>[n(l,{color:"blue"},{default:p(()=>s[10]||(s[10]=[a("控制台输出")])),_:1})]),_:1}),s[35]||(s[35]=i("p",null,[i("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308181128564.png",alt:"image-20230818112801463",loading:"lazy"})],-1)),s[36]||(s[36]=i("h2",{id:"_4-修饰代码块",tabindex:"-1"},[a("4. 修饰代码块 "),i("a",{class:"header-anchor",href:"#_4-修饰代码块","aria-label":'Permalink to "4. 修饰代码块"'},"​")],-1)),i("p",null,[i("strong",null,[n(l,{color:"blue"},{default:p(()=>s[11]||(s[11]=[a("说明")])),_:1})])]),s[37]||(s[37]=t("",4)),n(l,{size:"5"},{default:p(()=>[n(l,{color:"blue"},{default:p(()=>s[12]||(s[12]=[a("控制台输出")])),_:1})]),_:1}),s[38]||(s[38]=i("p",null,[i("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308181132009.png",alt:"image-20230818113217885",loading:"lazy"})],-1)),s[39]||(s[39]=i("h2",{id:"_5-修饰内部类",tabindex:"-1"},[a("5. 修饰内部类 "),i("a",{class:"header-anchor",href:"#_5-修饰内部类","aria-label":'Permalink to "5. 修饰内部类"'},"​")],-1)),n(l,{size:"4"},{default:p(()=>s[13]||(s[13]=[i("span",{style:{color:"red"}},"static",-1)])),_:1}),s[40]||(s[40]=a(" 不能修饰普通类，但可以修饰内部类。原因如下：")),n(l,{size:"4"},{default:p(()=>s[14]||(s[14]=[i("span",{style:{color:"red"}},"static",-1)])),_:1}),s[41]||(s[41]=a(" 修饰的东西被我们成为类成员，它会随着类的加载而加载，比如：静态代码块，静态成员，静态方法(这里只是加载，并没有调用)等等。若把一个Class文件中的外部类设为")),n(l,{size:"4"},{default:p(()=>s[15]||(s[15]=[i("span",{style:{color:"red"}},"static",-1)])),_:1}),s[42]||(s[42]=a("，那目的何在呢？难道让这个类随着应用的启动而加载吗？如果我在这次使用过程中根本没有使用过这个类，那么是不是就会浪费内存。这样来说设计不合理，总而言之，设计不合理的地方，Java是不会让它存在的。")),i("p",null,[s[18]||(s[18]=a("为什么内部类可以使用 ")),n(l,{size:"4"},{default:p(()=>s[16]||(s[16]=[i("span",{style:{color:"red"}},"static",-1)])),_:1}),s[19]||(s[19]=a(" 修饰呢，因为内部类算是类的成员了，如果我们没有使用静态来修饰，那么我们在创建内部类的时候就需要先有一个外部类的对象，如果我们一直在使用内部类，那么内存中就会一直存在外部类的引用，而我们有时候只需要使用内部类，不需要外部类，那么还是会浪费内存，甚至会造成内存溢出。使用 ")),n(l,{size:"4"},{default:p(()=>s[17]||(s[17]=[i("span",{style:{color:"red"}},[i("strong",null,"static")],-1)])),_:1}),s[20]||(s[20]=a("修饰内部类之后，内部类在创建对象时就不需要有外部类对象的引用了。"))]),s[43]||(s[43]=t("",5)),n(l,{size:"5"},{default:p(()=>[n(l,{color:"blue"},{default:p(()=>s[21]||(s[21]=[a("控制台输出")])),_:1})]),_:1}),s[44]||(s[44]=i("p",null,[i("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308181140104.png",alt:"image-20230818114056989",loading:"lazy"})],-1)),s[45]||(s[45]=i("p",null,"从上述结果可见，实例对象可以访问访问类变量。",-1))])}const A=e(d,[["render",g]]);export{m as __pageData,A as default};
