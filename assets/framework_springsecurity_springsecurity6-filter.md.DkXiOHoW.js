import{_ as r,B as s,o as a,c as n,j as t,a as o,G as l,a8 as c}from"./chunks/framework.D0fTRY1a.js";const y=JSON.parse('{"title":"SpringSecurity6 | 回顾Filter","description":"","frontmatter":{},"headers":[],"relativePath":"framework/springsecurity/springsecurity6-filter.md","filePath":"framework/springsecurity/springsecurity6-filter.md","lastUpdated":null}'),p={name:"framework/springsecurity/springsecurity6-filter.md"};function d(h,e,g,u,m,S){const i=s("ArticleMetadata");return a(),n("div",null,[e[0]||(e[0]=t("h1",{id:"springsecurity6-回顾filter",tabindex:"-1"},[o("SpringSecurity6 | 回顾Filter "),t("a",{class:"header-anchor",href:"#springsecurity6-回顾filter","aria-label":'Permalink to "SpringSecurity6 | 回顾Filter"'},"​")],-1)),l(i),e[1]||(e[1]=c(`<p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202310302354916.png" alt="image-20231030235443828" loading="lazy"></p><h2 id="_1-前言" tabindex="-1">1.前言 <a class="header-anchor" href="#_1-前言" aria-label="Permalink to &quot;1.前言&quot;">​</a></h2><p>大家好，我是Leo哥🫣🫣🫣，上一节我们通过一个HelloWorld案例，以代码的方式实现了我们项目添加登录鉴权功能，只是通过一个就轻松实现了这个功能。那么他其中的原理是什么呢，带着疑问，我们后面几节课主要学习一下如何实现这些的原理。好了，话不多说让我们开始吧😎😎😎。</p><h2 id="_2-遗留问题" tabindex="-1">2.遗留问题 <a class="header-anchor" href="#_2-遗留问题" aria-label="Permalink to &quot;2.遗留问题&quot;">​</a></h2><ol><li>在引入SpringSecurity依赖后，为什么所有请求就需要先做登录认证了呢?</li><li>登录页面是怎么产生的?</li><li>登录页面可以自定义吗?</li></ol><p><strong>后面几篇文章，我们会带着这些问题去研究SpringSecurity，并找出问题的答案。</strong></p><h2 id="_3-请求流程" tabindex="-1">3.请求流程 <a class="header-anchor" href="#_3-请求流程" aria-label="Permalink to &quot;3.请求流程&quot;">​</a></h2><p>一个请求发出之后的基本流程是怎么样的呢，我们的请求是如何被拦截的呢，下面我们简单的来看一下流程图。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311052218806.png" alt="image-20231105221856734" loading="lazy"></p><p><strong>流程详解：</strong></p><ol><li>客户端通过浏览器或其他方式向服务器发送请求，<strong>SpringSecurity</strong>会拦截该请求，并将其交给安全过滤器链进行处理。</li><li>安全过滤器链是<strong>SpringSecurity</strong>的核心组件，由多个**过滤器(Filter)**组成。每个过滤器都有特定的功能，例如身份验证、授权、会话管理等。在处理请求时，安全过滤器链会按照预定义的顺序依次调用各个过滤器，直到最后一个过滤器完成处理。</li><li>身份验证是SpringSecurity中的一个重要功能，它能够验证请求的发起者是否具有访问受保护资源的权限，通常是通过用户名和密码来验证身份。在安全过滤器链中，如果存在身份验证相关的过滤器，则会自动进行身份验证操作，例如<strong>UsernamePasswordAuthenticationFilter</strong>。</li><li>如果请求通过了身份验证和授权操作，<strong>SpringSecurity</strong>会将请求转发给受保护资源，并返回相应的响应；否则，会返回相应的错误信息或者直接跳转登录页面。</li></ol><p><strong>SpringSecurity对于Servlet的支持是基于Servlet Filter的。也就是说SpringSecurity的实现技术手段也是Filter。</strong></p><h2 id="_4-回顾filter" tabindex="-1">4.回顾Filter <a class="header-anchor" href="#_4-回顾filter" aria-label="Permalink to &quot;4.回顾Filter&quot;">​</a></h2><h3 id="_4-1过滤器回顾" tabindex="-1">4.1过滤器回顾 <a class="header-anchor" href="#_4-1过滤器回顾" aria-label="Permalink to &quot;4.1过滤器回顾&quot;">​</a></h3><p>SpringSecurity 的 Servlet 支持是基于 Servlet Filter 的，因此首先大致了解一下 <strong>Filter</strong> 的作用是有帮助的。下图显示了单个 <strong>HTTP请求</strong>的处理程序的典型分层。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311052223465.png" alt="image-20231105222301402" style="zoom:25%;"><p>客户端向应用程序发送请求，容器创建一个 <code>FilterChain</code> ，其中包含 <code>Filter</code> 实例和应处理 <code>HttpServletRequest</code> 是 <code>DispatcherServlet</code> 的实例。最多一个 <code>Servlet</code> 可以处理单个 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 。然而，多个 <code>Filter</code> 可用于：</p><ul><li>Prevent downstream <code>Filter</code> instances or the <code>Servlet</code> from being invoked. In this case, the <code>Filter</code> typically writes the <code>HttpServletResponse</code>. 防止调用下游 <code>Filter</code> 实例或 <code>Servlet</code> 。在这种情况下， <code>Filter</code> 通常写入 <code>HttpServletResponse</code> 。</li><li>Modify the <code>HttpServletRequest</code> or <code>HttpServletResponse</code> used by the downstream <code>Filter</code> instances and the <code>Servlet</code>. 修改下游 <code>Filter</code> 实例和 <code>Servlet</code> 使用的 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code> 。</li></ul><h3 id="_4-2过滤器核心" tabindex="-1">4.2过滤器核心 <a class="header-anchor" href="#_4-2过滤器核心" aria-label="Permalink to &quot;4.2过滤器核心&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ServletRequest request, ServletResponse response, FilterChain chain) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// do something before the rest of the application</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    chain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request, response); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// invoke the rest of the application</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // do something after the rest of the application</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于 <code>Filter</code> 仅影响下游 <code>Filter</code> 实例和 <code>Servlet</code> ，因此调用每个 <code>Filter</code> 的顺序非常重要。</p><h2 id="_5-过滤器分类" tabindex="-1">5.过滤器分类 <a class="header-anchor" href="#_5-过滤器分类" aria-label="Permalink to &quot;5.过滤器分类&quot;">​</a></h2><ol><li><strong>SecurityContextPersistenceFilter：</strong> 该过滤器用来确保在整个请求过程中**SecurityContext(安全上下文)**得以保留和传递。SecurityContext主要是用来存储当前用户的身份信息、角色、权限等。</li><li><strong>LogoutFilter：</strong> 该过滤器用来处理用户注销请求，通常会清除当前用户的身份信息。</li><li><strong>UsernamePasswordAuthenticationFilter：</strong> 该过滤器用来处理基于用户名和密码的身份认证请求。</li><li><strong>RequestCacheAwareFilter：</strong> 该过滤器用来缓存请求，以便后续重定向请求时可以正确地恢复请求状态。</li><li><strong>ExceptionTranslationFilter：</strong> 该过滤器用来处理由AccessDeniedHandler和AuthenticationEntryPoint抛出的异常，将它们转化为合适的HTTP响应。</li><li><strong>FilterSecurityInterceptor：</strong> 该过滤器用来进行授权操作，决定是否允许用户访问受保护资源。</li></ol><h2 id="_6-参考文献" tabindex="-1">6.参考文献 <a class="header-anchor" href="#_6-参考文献" aria-label="Permalink to &quot;6.参考文献&quot;">​</a></h2><ul><li><a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html" target="_blank" rel="noreferrer">https://docs.spring.io/spring-security/reference/servlet/architecture.html</a></li></ul><h2 id="_7-总结" tabindex="-1">7.总结 <a class="header-anchor" href="#_7-总结" aria-label="Permalink to &quot;7.总结&quot;">​</a></h2><p>以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是<strong>Leo</strong>，一个在互联网行业的小白，立志成为更好的自己。</p><p>如果你想了解更多关于<strong>Leo</strong>，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。</p>`,28))])}const b=r(p,[["render",d]]);export{y as __pageData,b as default};
